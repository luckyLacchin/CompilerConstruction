/* File generated by the BNF Converter (bnfc 2.9.5). */

/*** Visitor Design Pattern CodeGen. ***/
/* This implements the common visitor design pattern.
   Note that this method uses Visitor-traversal of lists, so
   List->accept() does NOT traverse the list. This allows different
   algorithms to use context information differently. */

#include "CodeGen.H"

llvm::Type *CodeGen::resolveStrType(std::string type)
{
  if (type == "int")
  {
    return llvm::Type::getInt32Ty(*context);
  }
  else if (type == "bool")
  {
    return llvm::Type::getInt1Ty(*context);
  }
  else if (type == "void")
  {
    return llvm::Type::getVoidTy(*context);
  }
  else
  {
    llvm::StructType *structType = module->getTypeByName(type);
    if (!structType)
    {
      llvm::errs() << ";Error: Type " << curType << " not found.\n";
      exit(1);
    }
    return structType;
  }
}

llvm::Value *CodeGen::resolveValuePointer(llvm::Value *v)
{
  if (v->getType()->isPointerTy())
  {
    return builder->CreateLoad(v->getType()->getPointerElementType(), v);
  }
  else
  {
    return v;
  }
}

void CodeGen::dumpLLVMIR()
{
  module->print(llvm::outs(), nullptr);
}

void CodeGen::visitProgram(Program *t) {} // abstract class
void CodeGen::visitDef(Def *t) {}         // abstract class
void CodeGen::visitField(Field *t) {}     // abstract class
void CodeGen::visitStm(Stm *t) {}         // abstract class
void CodeGen::visitExp(Exp *t) {}         // abstract class
void CodeGen::visitType(Type *t) {}       // abstract class

void CodeGen::visitPDefs(PDefs *p_defs)
{
  if (p_defs->listdef_)
    p_defs->listdef_->accept(this);
}

void CodeGen::visitDVar(DVar *d_var)
{
  if (d_var->type_)
    d_var->type_->accept(this);

  llvm::Type *varType;
  bool isInt = false;
  switch (resolveOption(curType))
  {
  case Option_int:
    varType = builder->getInt32Ty();
    isInt = true;
    break;
  case Option_bool:
    varType = builder->getInt1Ty();
    isInt = true;
    break;
  default:
    // Assuming that we are here when it encounters a struct type
    std::string structTypeName = curType;
    llvm::Type *structTypeExist = module->getTypeByName(structTypeName);
    if (!structTypeExist)
    {
      llvm::errs() << ";Error: Struct type " << structTypeName << " not found.\n";
      return;
    }
    llvm::StructType *structType = llvm::cast<llvm::StructType>(module->getTypeByName(structTypeName));

    varType = structType;

    break;
  }

  // Create global variable
  llvm::GlobalVariable *globalVar = new llvm::GlobalVariable(
      *module,
      varType,                            // Type of the global variable
      false,                              // Not constant
      llvm::GlobalValue::InternalLinkage, // Linkage
      0,                                  // Initial value
      d_var->ident_);

  // initialize global variables with 0
  llvm::ConstantInt *initialValue = llvm::ConstantInt::get(*context, llvm::APInt(/*nbits*/ 32, 0, /*bool*/ false));
  ;
  if (isInt)
  {
    globalVar->setInitializer(initialValue);
  }
  else
  {
    // zeroinitializer for declaration of type struct
    llvm::ConstantAggregateZero *const_struct = llvm::ConstantAggregateZero::get(varType);
    globalVar->setInitializer(const_struct);
  }
}

void CodeGen::visitDFun(DFun *d_fun)
{
  // get the return type of the function
  if (d_fun->type_)
    d_fun->type_->accept(this);
  llvm::Type *funcType = resolveStrType(curType);

  // create function type
  llvm::FunctionType *functionType = llvm::FunctionType::get(
      funcType, // Return type
      false);   // Variadic argument list: false for non-variadic

  // add function to module
  llvm::Function *function = llvm::Function::Create(
      functionType,                    // Function type
      llvm::Function::InternalLinkage, // Linkage
      d_fun->ident_,                   // Name of the function
      *module);                        // Module to add the function to

  // set up entry basic block
  llvm::BasicBlock *entry = llvm::BasicBlock::Create(*context, "functionEntry", function);
  builder->SetInsertPoint(entry);

  // set hasReturnStm flag
  hasReturnStm = false;

  // visit the list of statements
  if (d_fun->liststm_)
    d_fun->liststm_->accept(this);

  // check that the function has a return statement if it does not have a void return type
  if (!hasReturnStm && !funcType->isVoidTy())
  {
    llvm::errs() << ";Error: Function " << d_fun->ident_ << " does not have a return statement.\n";
    exit(1);
  }

  // clear the insertion point
  builder->ClearInsertionPoint();
}

void CodeGen::visitDStruct(DStruct *d_struct)
{
  std::string structTypeName = d_struct->ident_;

  // Visit list of fields to populate curfieldTypes and curFieldNames
  if (d_struct->listfield_)
  {
    d_struct->listfield_->accept(this);
  }

  // Create and define the struct type with its body (field types)
  llvm::ArrayRef<llvm::Type *> fieldTypes(curfieldTypes); // Convert std::vector to llvm::ArrayRef
  llvm::StructType *structType = llvm::StructType::create(*context, fieldTypes, structTypeName);

  // Add the struct type to the module
  module->getOrInsertNamedMetadata(d_struct->ident_);
  // Store the struct fields for lookup
  structDefs[structTypeName] = curFieldNames;
}

void CodeGen::visitFDecl(FDecl *f_decl)
{
  if (f_decl->type_)
    f_decl->type_->accept(this);
  curId = f_decl->ident_;
}

void CodeGen::visitSExp(SExp *s_exp)
{
  /* Code For SExp Goes Here */

  if (s_exp->exp_)
    s_exp->exp_->accept(this);
}

void CodeGen::visitSReturn(SReturn *s_return)
{
  // get expression type
  if (s_return->exp_)
    s_return->exp_->accept(this);
  llvm::Type *expType = resolveStrType(curType);

  // set hasReturnStm flag
  hasReturnStm = true;

  // check that the return type of the expression matches the return type of the function
  llvm::Type *funcType = builder->GetInsertBlock()->getParent()->getReturnType();
  if (expType != funcType)
  {
    llvm::errs() << ";Error: Return type mismatch. Expected " << *funcType << ", but got " << *expType << ".\n";
    exit(1);
  }

  curValue = resolveValuePointer(curValue);

  // create return instruction
  builder->CreateRet(curValue);
}

void CodeGen::visitSReturnV(SReturnV *s_return_v)
{
  // set hasReturnStm flag
  hasReturnStm = true;

  // check that the function has a void return type
  llvm::Type *funcType = builder->GetInsertBlock()->getParent()->getReturnType();
  if (!funcType->isVoidTy())
  {
    llvm::errs() << ";Error: Return type mismatch. Expected " << *funcType << ", but got void.\n";
    exit(1);
  }

  // create return instruction
  builder->CreateRetVoid();
}

void CodeGen::visitSWhile(SWhile *s_while)
{
  llvm::Function *function = builder->GetInsertBlock()->getParent();

  // Create basic blocks for the while loop
  llvm::BasicBlock *loopCondition = llvm::BasicBlock::Create(*context, "loopCondition", function);
  llvm::BasicBlock *loopBody = llvm::BasicBlock::Create(*context, "loopBody", function);
  llvm::BasicBlock *loopEnd = llvm::BasicBlock::Create(*context, "loopEnd", function);

  // Branch to the loop condition
  builder->CreateBr(loopCondition);

  // Set insertion point at the loop condition
  builder->SetInsertPoint(loopCondition);

  // Evaluate the loop condition
  llvm::Value *condition;
  if (s_while->exp_)
  {
    s_while->exp_->accept(this); // Assuming accept method exists for expression
  }
  condition = resolveValuePointer(curValue);
  condition = builder->CreateICmpNE(condition, llvm::ConstantInt::get(condition->getType(), 0), "loopCondition");

  // Branch to either loop body or loop end based on condition
  builder->CreateCondBr(condition, loopBody, loopEnd);

  // Set insertion point at the loop body
  builder->SetInsertPoint(loopBody);

  // Visit the loop body statement
  if (s_while->stm_)
    s_while->stm_->accept(this);

  // After executing the loop body, branch back to loop condition
  builder->CreateBr(loopCondition);

  // Set insertion point at the loop end
  builder->SetInsertPoint(loopEnd);
}

void CodeGen::visitSDoWhile(SDoWhile *s_do_while)
{
  // create the loop entry and after loop basic blocks
  llvm::Function *function = builder->GetInsertBlock()->getParent();
  llvm::BasicBlock *loopStm = llvm::BasicBlock::Create(*context, "loopStm", function);
  llvm::BasicBlock *afterLoop = llvm::BasicBlock::Create(*context, "afterLoop", function);

  // create and set the unconditional branch to the loop entry
  builder->CreateBr(loopStm);
  builder->SetInsertPoint(loopStm);

  // add instructions of statement to loop basic block
  if (s_do_while->stm_)
    s_do_while->stm_->accept(this);

  // create instructions for the loop condition
  if (s_do_while->exp_)
    s_do_while->exp_->accept(this);

  // check that loop condition is of type bool
  if (!curValue->getType()->isIntegerTy(1))
  {
    llvm::errs() << ";Error: Do-While loop condition must be of type bool. Got " << *curValue->getType() << ".\n";
    exit(1);
  }

  // create the loop condition check
  llvm::Value *condition = curValue;
  llvm::Value *conditionCheck = builder->CreateICmpNE(
      condition,
      llvm::ConstantInt::get(condition->getType(), 0),
      "loopcond");

  // create and set the conditional branch to the loop entry or after loop
  builder->CreateCondBr(conditionCheck, loopStm, afterLoop);
  builder->SetInsertPoint(afterLoop);
}

void CodeGen::visitSFor(SFor *s_for)
{
  if (s_for->exp_1)
    s_for->exp_1->accept(this);

  llvm::Function *function = builder->GetInsertBlock()->getParent();
  llvm::BasicBlock *loopBB = llvm::BasicBlock::Create(*context, "loop", function);
  llvm::BasicBlock *afterBB = llvm::BasicBlock::Create(*context, "afterloop", function);

  builder->CreateBr(loopBB);

  builder->SetInsertPoint(loopBB);

  llvm::Value *condition = nullptr;
  if (s_for->exp_2)
  {
    s_for->exp_2->accept(this);
  }
  condition = curValue;
  llvm::Value *conditionCheck = builder->CreateICmpNE(condition, llvm::ConstantInt::get(condition->getType(), 0), "loopcond");

  builder->CreateCondBr(conditionCheck, loopBB, afterBB);

  builder->SetInsertPoint(afterBB);

  if (s_for->exp_3)
    s_for->exp_3->accept(this);
}

void CodeGen::visitSBlock(SBlock *s_block)
{
  /* Code For SBlock Goes Here */

  if (s_block->liststm_)
    s_block->liststm_->accept(this);
}

void CodeGen::visitSIfElse(SIfElse *s_if_else)
{
  /* Code For SIfElse Goes Here */

  if (s_if_else->exp_)
    s_if_else->exp_->accept(this);

  llvm::Value *condValue = curValue;
  if (condValue == nullptr)
  {
    llvm::errs() << ";Null condition for if-else statement";
  }

  llvm::Function *parentFunction = builder->GetInsertBlock()->getParent();

  // create basic blocks
  llvm::BasicBlock *thenBB = llvm::BasicBlock::Create(*context, "then", parentFunction);
  llvm::BasicBlock *elseBB = llvm::BasicBlock::Create(*context, "else");
  llvm::BasicBlock *mergeBB = llvm::BasicBlock::Create(*context, "ifcont");

  builder->CreateCondBr(condValue, thenBB, elseBB);

  builder->SetInsertPoint(thenBB);
  if (s_if_else->stm_1)
    s_if_else->stm_1->accept(this);
  llvm::Value *thenValue = curValue;
  if (thenValue == nullptr)
  {
    llvm::errs() << ";Null then expression for if-else statement";
  }

  thenBB = builder->GetInsertBlock();
  builder->CreateBr(mergeBB);

  // else block
  parentFunction->getBasicBlockList().push_back(elseBB);
  builder->SetInsertPoint(elseBB);
  if (s_if_else->stm_2)
    s_if_else->stm_2->accept(this);
  llvm::Value *elseValue = curValue;
  if (condValue == nullptr)
  {
    llvm::errs() << ";Null else expression for if-else statement";
  }

  elseBB = builder->GetInsertBlock();
  builder->CreateBr(mergeBB);

  parentFunction->getBasicBlockList().push_back(mergeBB);
  builder->SetInsertPoint(mergeBB);
}

void CodeGen::visitETrue(ETrue *e_true)
{
  /* Code For ETrue Goes Here */
  curValue = llvm::ConstantInt::get(builder->getInt1Ty(), 1);
}

void CodeGen::visitEFalse(EFalse *e_false)
{
  /* Code For EFalse Goes Here */
  curValue = llvm::ConstantInt::get(builder->getInt1Ty(), 0);
}

void CodeGen::visitEInt(EInt *e_int)
{
  /* Code For EInt Goes Here */
  int curInt = e_int->integer_;
  curValue = llvm::ConstantInt::get(*context, llvm::APInt(32, curInt));
  // visitInteger(e_int->integer_); // it doesn't do anything, i do the association of the integer value here
}

void CodeGen::visitEIdent(EIdent *e_ident)
{
  /* Code For EIdent Goes Here */
  curId = e_ident->ident_;
  curValue = module->getNamedGlobal(curId);
}

void CodeGen::visitEApp(EApp *e_app)
{
  /* Code For EApp Goes Here */
  // It is used when we are calling a function, we're always assuming that we don't have to handle errors
  // visitIdent(e_app->ident_);

  std::string funcName = e_app->ident_;
  llvm::Function *calleeFun = module->getFunction(llvm::StringRef(funcName));
  // call instruction, there are not args, so the second parameter is NULL. There are not args according to the language specification!!!
  curValue = builder->CreateCall(calleeFun);
}

void CodeGen::visitEProj(EProj *e_proj)
{
  // Visit the expression to get the struct instance
  if (e_proj->exp_)
  {
    e_proj->exp_->accept(this);
  }
  // curValue = module->getNamedGlobal(curId);

  if (!curValue)
  {
    llvm::errs() << ";Error: Global variable " << curId << " not found.\n";
    return;
  }
  // curValue = resolveValuePointer(curValue);
  //  get the type of the global variable
  llvm::Type *curType = curValue->getType();
  llvm::Type *oldcurType = curType;
  // ensure that the global variable is a pointer type
  if (!curType->isPointerTy())
  {
    llvm::errs() << ";Error: Expected a pointer type for " << curId << ", but got " << *curType << ".\n";
    return;
  }

  // get the type pointed to by the global variable
  llvm::Type *structType = curValue->getType()->getPointerElementType();
  // ensure that the type pointed to is a struct type
  if (!structType->isStructTy())
  {
    llvm::errs() << ";Error: Expected a struct type for " << curId << ", but got " << *structType << ".\n";
    return;
  }

  std::string typeString;
  llvm::raw_string_ostream rso(typeString);
  curType->print(rso);
  typeString = rso.str();
  std::string substr = typeString.substr(1, typeString.length() - 2);

  llvm::StructType *llvmStructType = llvm::dyn_cast<llvm::StructType>(structType);
  std::string fieldName = e_proj->ident_;
  vector<string> fieldNames = structDefs[substr];

  int fieldIndex = 0;
  for (; fieldIndex < fieldNames.size(); ++fieldIndex)
  {
    if (fieldNames[fieldIndex] == fieldName)
    {
      break;
    }
  }
  if (fieldIndex == fieldNames.size())
  {
    llvm::errs() << ";Error: Field '" << fieldName << "' not found in struct type.\n";
    return;
  }
  // Load the struct instance
  llvm::Value *structInstance = resolveValuePointer(curValue);
  // Generate the GEP (GetElementPtr) instruction
  llvm::Value *fieldPtr = builder->CreateStructGEP(structType, curValue, fieldIndex);
  // llvm::errs() << "fieldPtr '" << *fieldPtr;
  //  Load the field value
  curValue = fieldPtr;
}

void CodeGen::visitEPIncr(EPIncr *ep_incr)
{
  /* Code For EPIncr Goes Here */

  if (ep_incr->exp_)
  {
    ep_incr->exp_->accept(this);
  }
  curValue = resolveValuePointer(curValue);
  llvm::Value *incrementedValue = builder->CreateAdd(curValue, llvm::ConstantInt::get(curValue->getType(), 1), "inctmp");

  // store the incremented value back to the variable's memory location via pointerVar
  builder->CreateStore(incrementedValue, curValue);

  // curValue = incrementedValue; // we set the new value!
}

void CodeGen::visitEPDecr(EPDecr *ep_decr)
{
  /* Code For EPDecr Goes Here */
  if (ep_decr->exp_)
  {
    ep_decr->exp_->accept(this);
  }

  curValue = resolveValuePointer(curValue);

  llvm::Value *decrementedValue = builder->CreateSub(curValue, llvm::ConstantInt::get(curValue->getType(), 1), "dectmp");

  // store the decremented value back to the variable's memory location via pointerVar
  builder->CreateStore(decrementedValue, curValue);
}

void CodeGen::visitEIncr(EIncr *e_incr)
{
  /* Code For EIncr Goes Here */

  if (e_incr->exp_)
  {
    e_incr->exp_->accept(this);
  }

curValue = resolveValuePointer(curValue);

  llvm::Value *incrementedValue = builder->CreateAdd(curValue, llvm::ConstantInt::get(curValue->getType(), 1), "inctmp");

  // store the incremented value back to the variable's memory location via pointerVar
  builder->CreateStore(incrementedValue, curValue);

  curValue = incrementedValue; // we set the new value!
}

void CodeGen::visitEDecr(EDecr *e_decr)
{
  /* Code For EDecr Goes Here */
  if (e_decr->exp_)
  {
    e_decr->exp_->accept(this);
  }

  curValue = resolveValuePointer(curValue);

  llvm::Value *decrementedValue = builder->CreateSub(curValue, llvm::ConstantInt::get(curValue->getType(), 1), "dectmp");

  // store the decremented value back to the variable's memory location via pointerVar
  builder->CreateStore(decrementedValue, curValue);

  curValue = decrementedValue; // we set the new value!
}

void CodeGen::visitEUPlus(EUPlus *eu_plus)
{
  /* Code For EUPlus Goes Here */

  if (eu_plus->exp_)
    eu_plus->exp_->accept(this);

  curValue = resolveValuePointer(curValue); // ist it necessary?
  // curValue has been set correctly as it is a = +b, we don't need to do anything. In the assignment the new value is set!
}

void CodeGen::visitEUMinus(EUMinus *eu_minus)
{
  /* Code For EUMinus Goes Here */

  if (eu_minus->exp_)
    eu_minus->exp_->accept(this);

  curValue = resolveValuePointer(curValue);

  // Store the negated value back into curValue, in this way in the assignment, for example, we are gonna store the newValue
  curValue = builder->CreateNeg(curValue, "negtmp");
}

void CodeGen::visitETimes(ETimes *e_times)
{
  /* Code For ETimes Goes Here */

  if (e_times->exp_1)
    e_times->exp_1->accept(this);

  curValue = resolveValuePointer(curValue);
  llvm::Value *lhs = curValue;

  if (e_times->exp_2)
    e_times->exp_2->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *rhs = curValue;

  curValue = builder->CreateMul(lhs, rhs, "multmp");
}

void CodeGen::visitEDiv(EDiv *e_div)
{
  /* Code For EDiv Goes Here */

  if (e_div->exp_1)
    e_div->exp_1->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *lhs = curValue;

  if (e_div->exp_2)
    e_div->exp_2->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *rhs = curValue;

  builder->CreateSDiv(lhs, rhs, "divtmp");
}

void CodeGen::visitEPlus(EPlus *e_plus)
{
  if (e_plus->exp_1)
    e_plus->exp_1->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *exp1 = curValue;

  if (e_plus->exp_2)
    e_plus->exp_2->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *exp2 = curValue;

  llvm::Value *result = builder->CreateAdd(exp1, exp2, "sum");

  curValue = result;
}

void CodeGen::visitEMinus(EMinus *e_minus)
{
  if (e_minus->exp_1)
    e_minus->exp_1->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *exp1 = curValue;

  if (e_minus->exp_2)
    e_minus->exp_2->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *exp2 = curValue;

  llvm::Value *result = builder->CreateSub(exp1, exp2, "diff");

  curValue = result;
}

void CodeGen::visitETwc(ETwc *e_twc)
{
  // Visit and resolve exp_1
  if (e_twc->exp_1)
    e_twc->exp_1->accept(this);
  llvm::Value *exp1 = resolveValuePointer(curValue);

  // Visit and resolve exp_2
  if (e_twc->exp_2)
    e_twc->exp_2->accept(this);
  llvm::Value *exp2 = resolveValuePointer(curValue);

  llvm::Function *function = builder->GetInsertBlock()->getParent();

  llvm::BasicBlock *returnLess = llvm::BasicBlock::Create(*context, "returnLess", function);
  llvm::BasicBlock *returnEqual = llvm::BasicBlock::Create(*context, "returnEqual", function);
  llvm::BasicBlock *returnGreater = llvm::BasicBlock::Create(*context, "returnGreater", function);
  llvm::BasicBlock *returnMerge = llvm::BasicBlock::Create(*context, "returnMerge", function);

  // Create comparison instructions
  llvm::Value *isLess = builder->CreateICmpSLT(exp1, exp2, "isLess");
  llvm::Value *isEqual = builder->CreateICmpEQ(exp1, exp2, "isEqual");
  llvm::Value *isGreater = builder->CreateICmpSGT(exp1, exp2, "isGreater");

  // Branch based on the comparison results
  builder->CreateCondBr(isLess, returnLess, returnEqual);
  builder->CreateCondBr(isEqual, returnEqual, returnGreater);

  // Set insertion point for returnLess block
  builder->SetInsertPoint(returnLess);
  builder->CreateBr(returnMerge);

  // Set insertion point for returnEqual block (already set by previous cond branch)

  // Set insertion point for returnGreater block
  builder->SetInsertPoint(returnGreater);
  builder->CreateBr(returnMerge);

  // Set insertion point for returnMerge block
  builder->SetInsertPoint(returnMerge);

  // Create PHI node to merge values from different blocks
  llvm::PHINode *phi = builder->CreatePHI(llvm::Type::getInt32Ty(*context), 3, "compareResult");
  phi->addIncoming(llvm::ConstantInt::get(llvm::Type::getInt32Ty(*context), -1), returnLess);
  phi->addIncoming(llvm::ConstantInt::get(llvm::Type::getInt32Ty(*context), 0), returnEqual);
  phi->addIncoming(llvm::ConstantInt::get(llvm::Type::getInt32Ty(*context), 1), returnGreater);

  // Store the result in curValue
  curValue = phi;
}

void CodeGen::visitELt(ELt *e_lt)
{
  if (e_lt->exp_1)
    e_lt->exp_1->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *LHS = curValue;

  if (e_lt->exp_2)
    e_lt->exp_2->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *RHS = curValue;

  // check that the types are the same
  if (LHS->getType() != RHS->getType())
  {
    llvm::errs() << ";Error: Types of LHS and RHS are not the same. Got " << *LHS->getType() << " and " << *RHS->getType() << ".\n";
    exit(1);
  }

  // check that the types are integers
  if (!LHS->getType()->isIntegerTy(32))
  {
    llvm::errs() << ";Error: Expected integer type for LHS. Got " << *LHS->getType() << ".\n";
    exit(1);
  }

  llvm::Value *comparisonResult = builder->CreateICmpSLT(LHS, RHS, "cmpLt");
  curValue = comparisonResult;
}

void CodeGen::visitEGt(EGt *e_gt)
{
  if (e_gt->exp_1)
    e_gt->exp_1->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *exp1 = curValue;

  if (e_gt->exp_2)
    e_gt->exp_2->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *exp2 = curValue;

  llvm::Function *function = builder->GetInsertBlock()->getParent();

  llvm::BasicBlock *returnGreater = llvm::BasicBlock::Create(*context, "returnGreater", function);
  llvm::BasicBlock *returnLE = llvm::BasicBlock::Create(*context, "returnLE", function);
  llvm::BasicBlock *returnMerge = llvm::BasicBlock::Create(*context, "returnMerge", function);

  // Generate boolean value for the comparison
  llvm::Value *greaterThan = builder->CreateICmpSGT(exp1, exp2, "greaterThan");

  // Branch based on the comparison
  builder->CreateCondBr(greaterThan, returnGreater, returnLE);

  // Set insertion point for returnGreater block
  builder->SetInsertPoint(returnGreater);
  builder->CreateBr(returnMerge); // Unconditional branch to merge block

  // Set insertion point for returnLE block
  builder->SetInsertPoint(returnLE);
  builder->CreateBr(returnMerge); // Unconditional branch to merge block

  // Set insertion point for returnMerge block
  builder->SetInsertPoint(returnMerge);

  // Assign the result directly to curValue
  curValue = greaterThan;
}

void CodeGen::visitELtEq(ELtEq *e_lt_eq)
{

  /* Code For ELtEq Goes Here */

  llvm::Value *lhsValue;
  if (e_lt_eq->exp_1)
    e_lt_eq->exp_1->accept(this);
  curValue = resolveValuePointer(curValue);
  lhsValue = curValue;

  llvm::Value *rhsValue;
  if (e_lt_eq->exp_2)
    e_lt_eq->exp_2->accept(this);
  curValue = resolveValuePointer(curValue);
  rhsValue = curValue;

  llvm::Value *comparisonResult = builder->CreateICmpSLE(lhsValue, rhsValue, "cmptmp");

  curValue = comparisonResult;
}

void CodeGen::visitEGtEq(EGtEq *e_gt_eq)
{
  /* Code For EGtEq Goes Here */
  if (e_gt_eq->exp_1)
    e_gt_eq->exp_1->accept(this);

  curValue = resolveValuePointer(curValue);
  llvm::Value *lhsValue = curValue;

  if (e_gt_eq->exp_2)
    e_gt_eq->exp_2->accept(this);

  curValue = resolveValuePointer(curValue);

  llvm::Value *rhsValue = curValue;
  if (lhsValue == nullptr || rhsValue == nullptr)
  {
    llvm::errs() << ";At least one null expression in EGtEq";
  }
  curValue = builder->CreateICmpSGE(lhsValue, rhsValue, "gteq");
}

void CodeGen::visitEEq(EEq *e_eq)
{
  /* Code For EEq Goes Here */

  if (e_eq->exp_1)
    e_eq->exp_1->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *lhsValue = curValue;

  if (e_eq->exp_2)
    e_eq->exp_2->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *rhsValue = curValue;

  // Check types
  if (lhsValue->getType() != rhsValue->getType())
  {
    // different types, return false
    curValue = builder->getInt1(false);
  }
  else
  {
    // same types, perform comparison
    llvm::Value *result = builder->CreateICmpEQ(lhsValue, rhsValue, "eqtmp");
    curValue = result;
  }
}

void CodeGen::visitENEq(ENEq *en_eq)
{
  /* Code For ENEq Goes Here */

  if (en_eq->exp_1)
    en_eq->exp_1->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *lhsValue = curValue;

  if (en_eq->exp_2)
    en_eq->exp_2->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *rhsValue = curValue;

  if (lhsValue->getType() != rhsValue->getType())
  {
    // different types, return true
    curValue = builder->getInt1(true);
  }
  else
  {
    // same types, perform comparison
    llvm::Value *result = builder->CreateICmpNE(lhsValue, rhsValue, "neqtmp");
    curValue = result;
  }
}

void CodeGen::visitEAnd(EAnd *e_and)
{
  llvm::Function *function = builder->GetInsertBlock()->getParent();

  llvm::BasicBlock *andBlock = llvm::BasicBlock::Create(*context, "and", function);
  llvm::BasicBlock *endBlock = llvm::BasicBlock::Create(*context, "endand", function);

  if (e_and->exp_1)
    e_and->exp_1->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *firstValue = curValue;

  // if the first expression is false
  builder->CreateCondBr(firstValue, andBlock, endBlock);

  // AND block
  builder->SetInsertPoint(andBlock);
  if (e_and->exp_2)
    e_and->exp_2->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *secondValue = curValue;

  // AND operation
  llvm::Value *result = builder->CreateAnd(firstValue, secondValue, "andtmp");

  builder->CreateBr(endBlock);

  builder->SetInsertPoint(endBlock);

  curValue = result;
}

void CodeGen::visitEOr(EOr *e_or)
{
  llvm::Function *function = builder->GetInsertBlock()->getParent();

  llvm::BasicBlock *orBlock = llvm::BasicBlock::Create(*context, "or", function);
  llvm::BasicBlock *endBlock = llvm::BasicBlock::Create(*context, "endor", function);

  if (e_or->exp_1)
    e_or->exp_1->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *firstValue = curValue;

  // if the first expression is true
  builder->CreateCondBr(firstValue, endBlock, orBlock);

  // Generate code for the OR block
  builder->SetInsertPoint(orBlock);
  if (e_or->exp_2)
    e_or->exp_2->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *secondValue = curValue;

  // OR operation
  llvm::Value *result = builder->CreateOr(firstValue, secondValue, "ortmp");

  builder->CreateBr(endBlock);

  builder->SetInsertPoint(endBlock);

  curValue = result;
}

void CodeGen::visitEAss(EAss *e_ass)
{
  /* Code For EAss Goes Here */

  if (e_ass->exp_1)
    e_ass->exp_1->accept(this);
  llvm::Value *lhsValue = curValue; // here we need the pointer as we need to store the new value

  if (e_ass->exp_2)
    e_ass->exp_2->accept(this);
  curValue = resolveValuePointer(curValue);
  llvm::Value *rhsValue = curValue;

  builder->CreateStore(rhsValue, lhsValue);

  curValue = rhsValue;
}

void CodeGen::visitECond(ECond *e_cond)
{
  // Evaluate the condition expression (exp1)
  if (e_cond->exp_1)
    e_cond->exp_1->accept(this);
  llvm::Value *conditionValue = curValue;

  // Get the current function and create basic blocks
  llvm::Function *function = builder->GetInsertBlock()->getParent();
  llvm::BasicBlock *trueBlock = llvm::BasicBlock::Create(*context, "trueBlock", function);
  llvm::BasicBlock *falseBlock = llvm::BasicBlock::Create(*context, "falseBlock", function);
  llvm::BasicBlock *endBlock = llvm::BasicBlock::Create(*context, "endBlock", function);

  // Conditional branch based on conditionValue
  builder->CreateCondBr(conditionValue, trueBlock, falseBlock);

  // Emit code for the true branch
  builder->SetInsertPoint(trueBlock);
  if (e_cond->exp_2)
    e_cond->exp_2->accept(this);
  llvm::Value *trueValue = curValue;
  builder->CreateBr(endBlock); // Ensure true block ends with a branch to endBlock

  // Emit code for the false branch
  builder->SetInsertPoint(falseBlock);
  if (e_cond->exp_3)
    e_cond->exp_3->accept(this);
  llvm::Value *falseValue = curValue;
  builder->CreateBr(endBlock); // Ensure false block ends with a branch to endBlock

  // Set insert point to the end block for PHI node
  builder->SetInsertPoint(endBlock);

  // Create PHI node to merge results from true and false branches
  llvm::PHINode *phi = builder->CreatePHI(llvm::Type::getInt32Ty(*context), 2, "condResult");
  phi->addIncoming(trueValue, trueBlock);
  phi->addIncoming(falseValue, falseBlock);

  // Update curValue to the PHI node result
  curValue = phi;
}

void CodeGen::visitType_bool(Type_bool *type_bool)
{
  /* Code For Type_bool Goes Here */
  // curType = llvm::Type::getInt1Ty(*context);
  curType = "bool";
}

void CodeGen::visitType_int(Type_int *type_int)
{
  /* Code For Type_int Goes Here */
  curType = "int";
}

void CodeGen::visitType_void(Type_void *type_void)
{
  /* Code For Type_void Goes Here */
  curType = "void";
}

void CodeGen::visitTypeIdent(TypeIdent *type_ident)
{
  /* Code For TypeIdent Goes Here */
  // this function is visited when we encounter a struct in the variable declaration
  curType = type_ident->ident_;
  visitIdent(type_ident->ident_);
}

void CodeGen::visitListDef(ListDef *list_def)
{
  for (ListDef::iterator i = list_def->begin(); i != list_def->end(); ++i)
  {
    (*i)->accept(this);
  }
}

void CodeGen::visitListField(ListField *list_field)
{
  curfieldTypes.clear();
  curFieldNames.clear();
  for (ListField::iterator i = list_field->begin(); i != list_field->end(); ++i)
  {
    (*i)->accept(this);

    // check that type is not void
    if (curType == "void")
    {
      llvm::errs() << ";Error: Field " << curId << " cannot have type void.\n";
      exit(1);
    }

    llvm::Type *fieldType = resolveStrType(curType);
    curfieldTypes.push_back(fieldType);
    curFieldNames.push_back(curId);
  }
}

void CodeGen::visitListStm(ListStm *list_stm)
{
  for (ListStm::iterator i = list_stm->begin(); i != list_stm->end(); ++i)
  {
    (*i)->accept(this);
  }
}

void CodeGen::visitInteger(Integer x)
{
  /* Code for Integer Goes Here */
  // we can keep it empty, because exp can't be of this type
}

void CodeGen::visitChar(Char x)
{
  /* Code for Char Goes Here */
  // we can keep it empty, because exp can't be of this type
}

void CodeGen::visitDouble(Double x)
{
  /* Code for Double Goes Here */
  // we can keep it empty, because exp can't be of this type
}

void CodeGen::visitString(String x)
{
  /* Code for String Goes Here */
  // we can keep it empty, because exp can't be of this type
}

void CodeGen::visitIdent(Ident x)
{
  /* Code for Ident Goes Here */
}
