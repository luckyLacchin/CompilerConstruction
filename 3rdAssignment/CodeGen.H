/* File generated by the BNF Converter (bnfc 2.9.5). */

#ifndef CODEGEN_HEADER
#define CODEGEN_HEADER
/* You might want to change the above name. */

#include "Absyn.H"
#include "llvm/IR/IRBuilder.h" // Inginous: ./CodeGen.H:8:10: fatal error: 'llvm/IR/IRBuilder.h' file not found
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/Type.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Instructions.h"
#include <string>
#include <cstring>
#include <vector>
#include <unordered_map>

using namespace std;

enum Options {
  Option_Invalid,
  Option_int,
  Option_bool,
  Option_void,
  // Option4,
};

static Options resolveOption(std::string input){
  static const std::map<std::string, Options> optionStrings{
    {"int", Option_int},
    {"bool", Option_bool},
    {"void", Option_void},
  };
  auto itr = optionStrings.find(input);
  if (itr != optionStrings.end()){
    return itr->second;
  }
  return Option_Invalid;
}

class CodeGen : public Visitor
{
private:
  std::unique_ptr<llvm::LLVMContext> context;
  std::unique_ptr<llvm::IRBuilder<>> builder;
  std::unique_ptr<llvm::Module> module;

  std::map<std::string, llvm::AllocaInst *> varEnv;
  vector<std::string> curFieldNames;

  std::vector<llvm::Type*> curfieldTypes; //to get the field types of a struct
  /*llvm::Type*/std::string curType;

  llvm::Value *curValue; //current value of the var pointed by pointerVar
  llvm::GlobalVariable *pointerVar; //pointer to the curVar

  std::string curId;
  bool hasReturnStm;
  unordered_map<string, vector<string>> structDefs;

public:
  CodeGen(){
    context = llvm::make_unique<llvm::LLVMContext>();
    builder = std::unique_ptr<llvm::IRBuilder<>>(new llvm::IRBuilder<>(*context));
    module = llvm::make_unique<llvm::Module>("Module", *context);
  }

  // helpers

  llvm::Type* resolveStrType(string type);
  llvm::Value* resolveValuePointer(llvm::Value *v); 

  void dumpLLVMIR();

  // visitor methods

  void visitProgram(Program *p);
  void visitDef(Def *p);
  void visitField(Field *p);
  void visitStm(Stm *p);
  void visitExp(Exp *p);
  void visitType(Type *p);
  void visitPDefs(PDefs *p);
  void visitDVar(DVar *p);
  void visitDFun(DFun *p); 
  void visitDStruct(DStruct *p);
  void visitFDecl(FDecl *p);
  void visitSExp(SExp *p);
  void visitSReturn(SReturn *p);
  void visitSReturnV(SReturnV *p);
  void visitSWhile(SWhile *p);
  void visitSDoWhile(SDoWhile *p);
  void visitSFor(SFor *p);
  void visitSBlock(SBlock *p);
  void visitSIfElse(SIfElse *p);
  void visitETrue(ETrue *p);
  void visitEFalse(EFalse *p);
  void visitEInt(EInt *p);
  void visitEIdent(EIdent *p);
  void visitEApp(EApp *p);
  void visitEProj(EProj *p);
  void visitEPIncr(EPIncr *p);
  void visitEPDecr(EPDecr *p);
  void visitEIncr(EIncr *p);
  void visitEDecr(EDecr *p);
  void visitEUPlus(EUPlus *p);
  void visitEUMinus(EUMinus *p);
  void visitETimes(ETimes *p);
  void visitEDiv(EDiv *p);
  void visitEPlus(EPlus *p);
  void visitEMinus(EMinus *p);
  void visitETwc(ETwc *p);
  void visitELt(ELt *p);
  void visitEGt(EGt *p);
  void visitELtEq(ELtEq *p);
  void visitEGtEq(EGtEq *p);
  void visitEEq(EEq *p);
  void visitENEq(ENEq *p);
  void visitEAnd(EAnd *p);
  void visitEOr(EOr *p);
  void visitEAss(EAss *p);
  void visitECond(ECond *p);
  void visitType_bool(Type_bool *p);
  void visitType_int(Type_int *p);
  void visitType_void(Type_void *p);
  void visitTypeIdent(TypeIdent *p);
  void visitListDef(ListDef *p);
  void visitListField(ListField *p);
  void visitListStm(ListStm *p);

  void visitInteger(Integer x);
  void visitChar(Char x);
  void visitDouble(Double x);
  void visitString(String x);
  void visitIdent(Ident x);
};


#endif
