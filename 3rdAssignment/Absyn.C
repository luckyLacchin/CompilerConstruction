/* File generated by the BNF Converter (bnfc 2.9.5). */

//C++ Abstract Syntax Implementation.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"

/********************   PDefs    ********************/
PDefs::PDefs(ListDef *p1)
{
  listdef_ = p1;

}

PDefs::PDefs(const PDefs & other)
{
  listdef_ = other.listdef_->clone();

}

PDefs &PDefs::operator=(const PDefs & other)
{
  PDefs tmp(other);
  swap(tmp);
  return *this;
}

void PDefs::swap(PDefs & other)
{
  std::swap(listdef_, other.listdef_);

}

PDefs::~PDefs()
{
  delete(listdef_);

}

void PDefs::accept(Visitor *v)
{
  v->visitPDefs(this);
}

PDefs *PDefs::clone() const
{
  return new PDefs(*this);
}



/********************   DVar    ********************/
DVar::DVar(Type *p1, Ident p2)
{
  type_ = p1;
  ident_ = p2;

}

DVar::DVar(const DVar & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;

}

DVar &DVar::operator=(const DVar & other)
{
  DVar tmp(other);
  swap(tmp);
  return *this;
}

void DVar::swap(DVar & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

DVar::~DVar()
{
  delete(type_);

}

void DVar::accept(Visitor *v)
{
  v->visitDVar(this);
}

DVar *DVar::clone() const
{
  return new DVar(*this);
}



/********************   DFun    ********************/
DFun::DFun(Type *p1, Ident p2, ListStm *p3)
{
  type_ = p1;
  ident_ = p2;
  liststm_ = p3;

}

DFun::DFun(const DFun & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;
  liststm_ = other.liststm_->clone();

}

DFun &DFun::operator=(const DFun & other)
{
  DFun tmp(other);
  swap(tmp);
  return *this;
}

void DFun::swap(DFun & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(liststm_, other.liststm_);

}

DFun::~DFun()
{
  delete(type_);
  delete(liststm_);

}

void DFun::accept(Visitor *v)
{
  v->visitDFun(this);
}

DFun *DFun::clone() const
{
  return new DFun(*this);
}



/********************   DStruct    ********************/
DStruct::DStruct(Ident p1, ListField *p2)
{
  ident_ = p1;
  listfield_ = p2;

}

DStruct::DStruct(const DStruct & other)
{
  ident_ = other.ident_;
  listfield_ = other.listfield_->clone();

}

DStruct &DStruct::operator=(const DStruct & other)
{
  DStruct tmp(other);
  swap(tmp);
  return *this;
}

void DStruct::swap(DStruct & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listfield_, other.listfield_);

}

DStruct::~DStruct()
{
  delete(listfield_);

}

void DStruct::accept(Visitor *v)
{
  v->visitDStruct(this);
}

DStruct *DStruct::clone() const
{
  return new DStruct(*this);
}



/********************   FDecl    ********************/
FDecl::FDecl(Type *p1, Ident p2)
{
  type_ = p1;
  ident_ = p2;

}

FDecl::FDecl(const FDecl & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;

}

FDecl &FDecl::operator=(const FDecl & other)
{
  FDecl tmp(other);
  swap(tmp);
  return *this;
}

void FDecl::swap(FDecl & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

FDecl::~FDecl()
{
  delete(type_);

}

void FDecl::accept(Visitor *v)
{
  v->visitFDecl(this);
}

FDecl *FDecl::clone() const
{
  return new FDecl(*this);
}



/********************   SExp    ********************/
SExp::SExp(Exp *p1)
{
  exp_ = p1;

}

SExp::SExp(const SExp & other)
{
  exp_ = other.exp_->clone();

}

SExp &SExp::operator=(const SExp & other)
{
  SExp tmp(other);
  swap(tmp);
  return *this;
}

void SExp::swap(SExp & other)
{
  std::swap(exp_, other.exp_);

}

SExp::~SExp()
{
  delete(exp_);

}

void SExp::accept(Visitor *v)
{
  v->visitSExp(this);
}

SExp *SExp::clone() const
{
  return new SExp(*this);
}



/********************   SReturn    ********************/
SReturn::SReturn(Exp *p1)
{
  exp_ = p1;

}

SReturn::SReturn(const SReturn & other)
{
  exp_ = other.exp_->clone();

}

SReturn &SReturn::operator=(const SReturn & other)
{
  SReturn tmp(other);
  swap(tmp);
  return *this;
}

void SReturn::swap(SReturn & other)
{
  std::swap(exp_, other.exp_);

}

SReturn::~SReturn()
{
  delete(exp_);

}

void SReturn::accept(Visitor *v)
{
  v->visitSReturn(this);
}

SReturn *SReturn::clone() const
{
  return new SReturn(*this);
}



/********************   SReturnV    ********************/
SReturnV::SReturnV()
{

}

SReturnV::SReturnV(const SReturnV & other)
{

}

SReturnV &SReturnV::operator=(const SReturnV & other)
{
  SReturnV tmp(other);
  swap(tmp);
  return *this;
}

void SReturnV::swap(SReturnV & other)
{

}

SReturnV::~SReturnV()
{

}

void SReturnV::accept(Visitor *v)
{
  v->visitSReturnV(this);
}

SReturnV *SReturnV::clone() const
{
  return new SReturnV(*this);
}



/********************   SWhile    ********************/
SWhile::SWhile(Exp *p1, Stm *p2)
{
  exp_ = p1;
  stm_ = p2;

}

SWhile::SWhile(const SWhile & other)
{
  exp_ = other.exp_->clone();
  stm_ = other.stm_->clone();

}

SWhile &SWhile::operator=(const SWhile & other)
{
  SWhile tmp(other);
  swap(tmp);
  return *this;
}

void SWhile::swap(SWhile & other)
{
  std::swap(exp_, other.exp_);
  std::swap(stm_, other.stm_);

}

SWhile::~SWhile()
{
  delete(exp_);
  delete(stm_);

}

void SWhile::accept(Visitor *v)
{
  v->visitSWhile(this);
}

SWhile *SWhile::clone() const
{
  return new SWhile(*this);
}



/********************   SDoWhile    ********************/
SDoWhile::SDoWhile(Stm *p1, Exp *p2)
{
  stm_ = p1;
  exp_ = p2;

}

SDoWhile::SDoWhile(const SDoWhile & other)
{
  stm_ = other.stm_->clone();
  exp_ = other.exp_->clone();

}

SDoWhile &SDoWhile::operator=(const SDoWhile & other)
{
  SDoWhile tmp(other);
  swap(tmp);
  return *this;
}

void SDoWhile::swap(SDoWhile & other)
{
  std::swap(stm_, other.stm_);
  std::swap(exp_, other.exp_);

}

SDoWhile::~SDoWhile()
{
  delete(stm_);
  delete(exp_);

}

void SDoWhile::accept(Visitor *v)
{
  v->visitSDoWhile(this);
}

SDoWhile *SDoWhile::clone() const
{
  return new SDoWhile(*this);
}



/********************   SFor    ********************/
SFor::SFor(Exp *p1, Exp *p2, Exp *p3, Stm *p4)
{
  exp_1 = p1;
  exp_2 = p2;
  exp_3 = p3;
  stm_ = p4;

}

SFor::SFor(const SFor & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();
  exp_3 = other.exp_3->clone();
  stm_ = other.stm_->clone();

}

SFor &SFor::operator=(const SFor & other)
{
  SFor tmp(other);
  swap(tmp);
  return *this;
}

void SFor::swap(SFor & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);
  std::swap(exp_3, other.exp_3);
  std::swap(stm_, other.stm_);

}

SFor::~SFor()
{
  delete(exp_1);
  delete(exp_2);
  delete(exp_3);
  delete(stm_);

}

void SFor::accept(Visitor *v)
{
  v->visitSFor(this);
}

SFor *SFor::clone() const
{
  return new SFor(*this);
}



/********************   SBlock    ********************/
SBlock::SBlock(ListStm *p1)
{
  liststm_ = p1;

}

SBlock::SBlock(const SBlock & other)
{
  liststm_ = other.liststm_->clone();

}

SBlock &SBlock::operator=(const SBlock & other)
{
  SBlock tmp(other);
  swap(tmp);
  return *this;
}

void SBlock::swap(SBlock & other)
{
  std::swap(liststm_, other.liststm_);

}

SBlock::~SBlock()
{
  delete(liststm_);

}

void SBlock::accept(Visitor *v)
{
  v->visitSBlock(this);
}

SBlock *SBlock::clone() const
{
  return new SBlock(*this);
}



/********************   SIfElse    ********************/
SIfElse::SIfElse(Exp *p1, Stm *p2, Stm *p3)
{
  exp_ = p1;
  stm_1 = p2;
  stm_2 = p3;

}

SIfElse::SIfElse(const SIfElse & other)
{
  exp_ = other.exp_->clone();
  stm_1 = other.stm_1->clone();
  stm_2 = other.stm_2->clone();

}

SIfElse &SIfElse::operator=(const SIfElse & other)
{
  SIfElse tmp(other);
  swap(tmp);
  return *this;
}

void SIfElse::swap(SIfElse & other)
{
  std::swap(exp_, other.exp_);
  std::swap(stm_1, other.stm_1);
  std::swap(stm_2, other.stm_2);

}

SIfElse::~SIfElse()
{
  delete(exp_);
  delete(stm_1);
  delete(stm_2);

}

void SIfElse::accept(Visitor *v)
{
  v->visitSIfElse(this);
}

SIfElse *SIfElse::clone() const
{
  return new SIfElse(*this);
}



/********************   ETrue    ********************/
ETrue::ETrue()
{

}

ETrue::ETrue(const ETrue & other)
{

}

ETrue &ETrue::operator=(const ETrue & other)
{
  ETrue tmp(other);
  swap(tmp);
  return *this;
}

void ETrue::swap(ETrue & other)
{

}

ETrue::~ETrue()
{

}

void ETrue::accept(Visitor *v)
{
  v->visitETrue(this);
}

ETrue *ETrue::clone() const
{
  return new ETrue(*this);
}



/********************   EFalse    ********************/
EFalse::EFalse()
{

}

EFalse::EFalse(const EFalse & other)
{

}

EFalse &EFalse::operator=(const EFalse & other)
{
  EFalse tmp(other);
  swap(tmp);
  return *this;
}

void EFalse::swap(EFalse & other)
{

}

EFalse::~EFalse()
{

}

void EFalse::accept(Visitor *v)
{
  v->visitEFalse(this);
}

EFalse *EFalse::clone() const
{
  return new EFalse(*this);
}



/********************   EInt    ********************/
EInt::EInt(Integer p1)
{
  integer_ = p1;

}

EInt::EInt(const EInt & other)
{
  integer_ = other.integer_;

}

EInt &EInt::operator=(const EInt & other)
{
  EInt tmp(other);
  swap(tmp);
  return *this;
}

void EInt::swap(EInt & other)
{
  std::swap(integer_, other.integer_);

}

EInt::~EInt()
{

}

void EInt::accept(Visitor *v)
{
  v->visitEInt(this);
}

EInt *EInt::clone() const
{
  return new EInt(*this);
}



/********************   EIdent    ********************/
EIdent::EIdent(Ident p1)
{
  ident_ = p1;

}

EIdent::EIdent(const EIdent & other)
{
  ident_ = other.ident_;

}

EIdent &EIdent::operator=(const EIdent & other)
{
  EIdent tmp(other);
  swap(tmp);
  return *this;
}

void EIdent::swap(EIdent & other)
{
  std::swap(ident_, other.ident_);

}

EIdent::~EIdent()
{

}

void EIdent::accept(Visitor *v)
{
  v->visitEIdent(this);
}

EIdent *EIdent::clone() const
{
  return new EIdent(*this);
}



/********************   EApp    ********************/
EApp::EApp(Ident p1)
{
  ident_ = p1;

}

EApp::EApp(const EApp & other)
{
  ident_ = other.ident_;

}

EApp &EApp::operator=(const EApp & other)
{
  EApp tmp(other);
  swap(tmp);
  return *this;
}

void EApp::swap(EApp & other)
{
  std::swap(ident_, other.ident_);

}

EApp::~EApp()
{

}

void EApp::accept(Visitor *v)
{
  v->visitEApp(this);
}

EApp *EApp::clone() const
{
  return new EApp(*this);
}



/********************   EProj    ********************/
EProj::EProj(Exp *p1, Ident p2)
{
  exp_ = p1;
  ident_ = p2;

}

EProj::EProj(const EProj & other)
{
  exp_ = other.exp_->clone();
  ident_ = other.ident_;

}

EProj &EProj::operator=(const EProj & other)
{
  EProj tmp(other);
  swap(tmp);
  return *this;
}

void EProj::swap(EProj & other)
{
  std::swap(exp_, other.exp_);
  std::swap(ident_, other.ident_);

}

EProj::~EProj()
{
  delete(exp_);

}

void EProj::accept(Visitor *v)
{
  v->visitEProj(this);
}

EProj *EProj::clone() const
{
  return new EProj(*this);
}



/********************   EPIncr    ********************/
EPIncr::EPIncr(Exp *p1)
{
  exp_ = p1;

}

EPIncr::EPIncr(const EPIncr & other)
{
  exp_ = other.exp_->clone();

}

EPIncr &EPIncr::operator=(const EPIncr & other)
{
  EPIncr tmp(other);
  swap(tmp);
  return *this;
}

void EPIncr::swap(EPIncr & other)
{
  std::swap(exp_, other.exp_);

}

EPIncr::~EPIncr()
{
  delete(exp_);

}

void EPIncr::accept(Visitor *v)
{
  v->visitEPIncr(this);
}

EPIncr *EPIncr::clone() const
{
  return new EPIncr(*this);
}



/********************   EPDecr    ********************/
EPDecr::EPDecr(Exp *p1)
{
  exp_ = p1;

}

EPDecr::EPDecr(const EPDecr & other)
{
  exp_ = other.exp_->clone();

}

EPDecr &EPDecr::operator=(const EPDecr & other)
{
  EPDecr tmp(other);
  swap(tmp);
  return *this;
}

void EPDecr::swap(EPDecr & other)
{
  std::swap(exp_, other.exp_);

}

EPDecr::~EPDecr()
{
  delete(exp_);

}

void EPDecr::accept(Visitor *v)
{
  v->visitEPDecr(this);
}

EPDecr *EPDecr::clone() const
{
  return new EPDecr(*this);
}



/********************   EIncr    ********************/
EIncr::EIncr(Exp *p1)
{
  exp_ = p1;

}

EIncr::EIncr(const EIncr & other)
{
  exp_ = other.exp_->clone();

}

EIncr &EIncr::operator=(const EIncr & other)
{
  EIncr tmp(other);
  swap(tmp);
  return *this;
}

void EIncr::swap(EIncr & other)
{
  std::swap(exp_, other.exp_);

}

EIncr::~EIncr()
{
  delete(exp_);

}

void EIncr::accept(Visitor *v)
{
  v->visitEIncr(this);
}

EIncr *EIncr::clone() const
{
  return new EIncr(*this);
}



/********************   EDecr    ********************/
EDecr::EDecr(Exp *p1)
{
  exp_ = p1;

}

EDecr::EDecr(const EDecr & other)
{
  exp_ = other.exp_->clone();

}

EDecr &EDecr::operator=(const EDecr & other)
{
  EDecr tmp(other);
  swap(tmp);
  return *this;
}

void EDecr::swap(EDecr & other)
{
  std::swap(exp_, other.exp_);

}

EDecr::~EDecr()
{
  delete(exp_);

}

void EDecr::accept(Visitor *v)
{
  v->visitEDecr(this);
}

EDecr *EDecr::clone() const
{
  return new EDecr(*this);
}



/********************   EUPlus    ********************/
EUPlus::EUPlus(Exp *p1)
{
  exp_ = p1;

}

EUPlus::EUPlus(const EUPlus & other)
{
  exp_ = other.exp_->clone();

}

EUPlus &EUPlus::operator=(const EUPlus & other)
{
  EUPlus tmp(other);
  swap(tmp);
  return *this;
}

void EUPlus::swap(EUPlus & other)
{
  std::swap(exp_, other.exp_);

}

EUPlus::~EUPlus()
{
  delete(exp_);

}

void EUPlus::accept(Visitor *v)
{
  v->visitEUPlus(this);
}

EUPlus *EUPlus::clone() const
{
  return new EUPlus(*this);
}



/********************   EUMinus    ********************/
EUMinus::EUMinus(Exp *p1)
{
  exp_ = p1;

}

EUMinus::EUMinus(const EUMinus & other)
{
  exp_ = other.exp_->clone();

}

EUMinus &EUMinus::operator=(const EUMinus & other)
{
  EUMinus tmp(other);
  swap(tmp);
  return *this;
}

void EUMinus::swap(EUMinus & other)
{
  std::swap(exp_, other.exp_);

}

EUMinus::~EUMinus()
{
  delete(exp_);

}

void EUMinus::accept(Visitor *v)
{
  v->visitEUMinus(this);
}

EUMinus *EUMinus::clone() const
{
  return new EUMinus(*this);
}



/********************   ETimes    ********************/
ETimes::ETimes(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ETimes::ETimes(const ETimes & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ETimes &ETimes::operator=(const ETimes & other)
{
  ETimes tmp(other);
  swap(tmp);
  return *this;
}

void ETimes::swap(ETimes & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ETimes::~ETimes()
{
  delete(exp_1);
  delete(exp_2);

}

void ETimes::accept(Visitor *v)
{
  v->visitETimes(this);
}

ETimes *ETimes::clone() const
{
  return new ETimes(*this);
}



/********************   EDiv    ********************/
EDiv::EDiv(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EDiv::EDiv(const EDiv & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EDiv &EDiv::operator=(const EDiv & other)
{
  EDiv tmp(other);
  swap(tmp);
  return *this;
}

void EDiv::swap(EDiv & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EDiv::~EDiv()
{
  delete(exp_1);
  delete(exp_2);

}

void EDiv::accept(Visitor *v)
{
  v->visitEDiv(this);
}

EDiv *EDiv::clone() const
{
  return new EDiv(*this);
}



/********************   EPlus    ********************/
EPlus::EPlus(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EPlus::EPlus(const EPlus & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EPlus &EPlus::operator=(const EPlus & other)
{
  EPlus tmp(other);
  swap(tmp);
  return *this;
}

void EPlus::swap(EPlus & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EPlus::~EPlus()
{
  delete(exp_1);
  delete(exp_2);

}

void EPlus::accept(Visitor *v)
{
  v->visitEPlus(this);
}

EPlus *EPlus::clone() const
{
  return new EPlus(*this);
}



/********************   EMinus    ********************/
EMinus::EMinus(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EMinus::EMinus(const EMinus & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EMinus &EMinus::operator=(const EMinus & other)
{
  EMinus tmp(other);
  swap(tmp);
  return *this;
}

void EMinus::swap(EMinus & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EMinus::~EMinus()
{
  delete(exp_1);
  delete(exp_2);

}

void EMinus::accept(Visitor *v)
{
  v->visitEMinus(this);
}

EMinus *EMinus::clone() const
{
  return new EMinus(*this);
}



/********************   ETwc    ********************/
ETwc::ETwc(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ETwc::ETwc(const ETwc & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ETwc &ETwc::operator=(const ETwc & other)
{
  ETwc tmp(other);
  swap(tmp);
  return *this;
}

void ETwc::swap(ETwc & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ETwc::~ETwc()
{
  delete(exp_1);
  delete(exp_2);

}

void ETwc::accept(Visitor *v)
{
  v->visitETwc(this);
}

ETwc *ETwc::clone() const
{
  return new ETwc(*this);
}



/********************   ELt    ********************/
ELt::ELt(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ELt::ELt(const ELt & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ELt &ELt::operator=(const ELt & other)
{
  ELt tmp(other);
  swap(tmp);
  return *this;
}

void ELt::swap(ELt & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ELt::~ELt()
{
  delete(exp_1);
  delete(exp_2);

}

void ELt::accept(Visitor *v)
{
  v->visitELt(this);
}

ELt *ELt::clone() const
{
  return new ELt(*this);
}



/********************   EGt    ********************/
EGt::EGt(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EGt::EGt(const EGt & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EGt &EGt::operator=(const EGt & other)
{
  EGt tmp(other);
  swap(tmp);
  return *this;
}

void EGt::swap(EGt & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EGt::~EGt()
{
  delete(exp_1);
  delete(exp_2);

}

void EGt::accept(Visitor *v)
{
  v->visitEGt(this);
}

EGt *EGt::clone() const
{
  return new EGt(*this);
}



/********************   ELtEq    ********************/
ELtEq::ELtEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ELtEq::ELtEq(const ELtEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ELtEq &ELtEq::operator=(const ELtEq & other)
{
  ELtEq tmp(other);
  swap(tmp);
  return *this;
}

void ELtEq::swap(ELtEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ELtEq::~ELtEq()
{
  delete(exp_1);
  delete(exp_2);

}

void ELtEq::accept(Visitor *v)
{
  v->visitELtEq(this);
}

ELtEq *ELtEq::clone() const
{
  return new ELtEq(*this);
}



/********************   EGtEq    ********************/
EGtEq::EGtEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EGtEq::EGtEq(const EGtEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EGtEq &EGtEq::operator=(const EGtEq & other)
{
  EGtEq tmp(other);
  swap(tmp);
  return *this;
}

void EGtEq::swap(EGtEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EGtEq::~EGtEq()
{
  delete(exp_1);
  delete(exp_2);

}

void EGtEq::accept(Visitor *v)
{
  v->visitEGtEq(this);
}

EGtEq *EGtEq::clone() const
{
  return new EGtEq(*this);
}



/********************   EEq    ********************/
EEq::EEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EEq::EEq(const EEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EEq &EEq::operator=(const EEq & other)
{
  EEq tmp(other);
  swap(tmp);
  return *this;
}

void EEq::swap(EEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EEq::~EEq()
{
  delete(exp_1);
  delete(exp_2);

}

void EEq::accept(Visitor *v)
{
  v->visitEEq(this);
}

EEq *EEq::clone() const
{
  return new EEq(*this);
}



/********************   ENEq    ********************/
ENEq::ENEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ENEq::ENEq(const ENEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ENEq &ENEq::operator=(const ENEq & other)
{
  ENEq tmp(other);
  swap(tmp);
  return *this;
}

void ENEq::swap(ENEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ENEq::~ENEq()
{
  delete(exp_1);
  delete(exp_2);

}

void ENEq::accept(Visitor *v)
{
  v->visitENEq(this);
}

ENEq *ENEq::clone() const
{
  return new ENEq(*this);
}



/********************   EAnd    ********************/
EAnd::EAnd(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAnd::EAnd(const EAnd & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAnd &EAnd::operator=(const EAnd & other)
{
  EAnd tmp(other);
  swap(tmp);
  return *this;
}

void EAnd::swap(EAnd & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAnd::~EAnd()
{
  delete(exp_1);
  delete(exp_2);

}

void EAnd::accept(Visitor *v)
{
  v->visitEAnd(this);
}

EAnd *EAnd::clone() const
{
  return new EAnd(*this);
}



/********************   EOr    ********************/
EOr::EOr(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EOr::EOr(const EOr & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EOr &EOr::operator=(const EOr & other)
{
  EOr tmp(other);
  swap(tmp);
  return *this;
}

void EOr::swap(EOr & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EOr::~EOr()
{
  delete(exp_1);
  delete(exp_2);

}

void EOr::accept(Visitor *v)
{
  v->visitEOr(this);
}

EOr *EOr::clone() const
{
  return new EOr(*this);
}



/********************   EAss    ********************/
EAss::EAss(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAss::EAss(const EAss & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAss &EAss::operator=(const EAss & other)
{
  EAss tmp(other);
  swap(tmp);
  return *this;
}

void EAss::swap(EAss & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAss::~EAss()
{
  delete(exp_1);
  delete(exp_2);

}

void EAss::accept(Visitor *v)
{
  v->visitEAss(this);
}

EAss *EAss::clone() const
{
  return new EAss(*this);
}



/********************   ECond    ********************/
ECond::ECond(Exp *p1, Exp *p2, Exp *p3)
{
  exp_1 = p1;
  exp_2 = p2;
  exp_3 = p3;

}

ECond::ECond(const ECond & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();
  exp_3 = other.exp_3->clone();

}

ECond &ECond::operator=(const ECond & other)
{
  ECond tmp(other);
  swap(tmp);
  return *this;
}

void ECond::swap(ECond & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);
  std::swap(exp_3, other.exp_3);

}

ECond::~ECond()
{
  delete(exp_1);
  delete(exp_2);
  delete(exp_3);

}

void ECond::accept(Visitor *v)
{
  v->visitECond(this);
}

ECond *ECond::clone() const
{
  return new ECond(*this);
}



/********************   Type_bool    ********************/
Type_bool::Type_bool()
{

}

Type_bool::Type_bool(const Type_bool & other)
{

}

Type_bool &Type_bool::operator=(const Type_bool & other)
{
  Type_bool tmp(other);
  swap(tmp);
  return *this;
}

void Type_bool::swap(Type_bool & other)
{

}

Type_bool::~Type_bool()
{

}

void Type_bool::accept(Visitor *v)
{
  v->visitType_bool(this);
}

Type_bool *Type_bool::clone() const
{
  return new Type_bool(*this);
}



/********************   Type_int    ********************/
Type_int::Type_int()
{

}

Type_int::Type_int(const Type_int & other)
{

}

Type_int &Type_int::operator=(const Type_int & other)
{
  Type_int tmp(other);
  swap(tmp);
  return *this;
}

void Type_int::swap(Type_int & other)
{

}

Type_int::~Type_int()
{

}

void Type_int::accept(Visitor *v)
{
  v->visitType_int(this);
}

Type_int *Type_int::clone() const
{
  return new Type_int(*this);
}



/********************   Type_void    ********************/
Type_void::Type_void()
{

}

Type_void::Type_void(const Type_void & other)
{

}

Type_void &Type_void::operator=(const Type_void & other)
{
  Type_void tmp(other);
  swap(tmp);
  return *this;
}

void Type_void::swap(Type_void & other)
{

}

Type_void::~Type_void()
{

}

void Type_void::accept(Visitor *v)
{
  v->visitType_void(this);
}

Type_void *Type_void::clone() const
{
  return new Type_void(*this);
}



/********************   TypeIdent    ********************/
TypeIdent::TypeIdent(Ident p1)
{
  ident_ = p1;

}

TypeIdent::TypeIdent(const TypeIdent & other)
{
  ident_ = other.ident_;

}

TypeIdent &TypeIdent::operator=(const TypeIdent & other)
{
  TypeIdent tmp(other);
  swap(tmp);
  return *this;
}

void TypeIdent::swap(TypeIdent & other)
{
  std::swap(ident_, other.ident_);

}

TypeIdent::~TypeIdent()
{

}

void TypeIdent::accept(Visitor *v)
{
  v->visitTypeIdent(this);
}

TypeIdent *TypeIdent::clone() const
{
  return new TypeIdent(*this);
}




/********************   ListDef    ********************/

void ListDef::accept(Visitor *v)
{
  v->visitListDef(this);
}

ListDef *ListDef::clone() const
{
  return new ListDef(*this);
}

ListDef* consListDef(Def* x, ListDef* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListField    ********************/

void ListField::accept(Visitor *v)
{
  v->visitListField(this);
}

ListField *ListField::clone() const
{
  return new ListField(*this);
}

ListField* consListField(Field* x, ListField* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListStm    ********************/

void ListStm::accept(Visitor *v)
{
  v->visitListStm(this);
}

ListStm *ListStm::clone() const
{
  return new ListStm(*this);
}

ListStm* consListStm(Stm* x, ListStm* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}





